1.单元测试Junit
	作用:测试代码---->白盒测试
	好处:
		1.可以直观通过观看颜色来判定方法是否写的有异常
		2.省去了定义主方法的过程
		3.方便大批量的方法一起测试
	使用步骤:
		1.定义一个类 --->类名最好是  被测试的类名XXX+ Test 或者 Test+被测试的类名XXX
		2.编写测试方法 
			1.测试方法的方法名 ---> test+被测试的方法名
			2.测试方法没有返回值
			3.测试方法没有参数列表
		3.在测试方法上添加注解@Test ---> alt + enter将依赖引入进来
2. 获取字节码的三种方式
	1.Class.forName(类的全类名(包名+类名))
		只需要一个全类名的字符串
	2.类名.class的属性来获取
		要类名
	3.通过对象.getClass()来获取
		要对象
3.作用:
	1.通过反射配置文件的全类名提高程序扩展性
	2.通过反射获取字段对象,对对象的字段进行赋值
	3.通过反射越过泛型检测
	4.暴力反射
		访问私有的东西--->记住一定解除安全检测 setAccessable(true);
	5. 通过反射和工厂设计模式实现解耦
4.反射常用的方法
	1.反射字段Filed
		作用:
			getFiled(字)段的字符串名字
			1.给对象的属性设置值
				set(要被设置的对象,要被设置的值);
			2.获取对象属性的值
				get(要被获取的对象)
	2.反射构造Constructor
		作用:
			getConstructor(所有参数的字节码对象)
			为了创建对象
			 T newInstance(构造方法的所有参数字节码文件) 
			 
				
	3.反射方法Method
		作用:
			getMethod(方法的名字,方法所有参数的字节码对象)
			为了调用方法
			 Object invoke(要执行方法的对象, 执行方法是需要的参数)  
5.注解
	定义格式:
		public @interface 注解名称{
		}
	本质上是一个接口默认继承Annotation
	
	属性:
		1.只能是以下类型
			1.基本数据类型
			2.String
			3.枚举
			4.注解
			5.以上数据类型一维数组
		注意事项:
			1.当属性的名字为value,并且只有value没有被赋值,value可以省略
			2.数组的值值只有一个的时候,{}可以省略不写,多个值用,隔开
	元注解:
		修饰注解的注解(jdk预先定义好的东西,来控制我们我们自定义的注解)
		@Target		:决定我们自定义注解的作用范围
			1.ElementType.METHOD--->在方法上面添加
			2.ElementType.TYPE --->在类上面添加
			3.ElementType.Field ---->在字段上添加
		@Retation	:决定我们自定义注解存在的时段
			1.RetentionPolicy.RUNTIME --->在运行期间,字节码期间,源码区间都可以得到注解
			2.RetentionPolicy.CLASS --->在字节码期间,源码区间都可以得到注解
			3.RetentionPolicy.SOURCE--->只能在源码期间能够获取到注解
		@Documented	:决定我们自定义的注解出现在api文档中
		@Inherit	:决定我们自定义注解能不能被继承
		注意:
			1.如果Target不写,默认是全范围
			2.如果Retation,只能存在源码阶段,运行期间是找不到这个注解的!!!
6.解析注解---->其实就是为了获取注解中的属性的值
	注解只能通过字节码对象来得到
	步骤:
		1.获取字节码
		2.注解在什么上面添加就获取什么对象(如果注解在类上面添加,就获取Class对象就行,如果注解在方法上添加就获取Method对象...)
		3.判断注解是否存在 | 获取注解的两个方法
			Annotation anno = getAnnotation(注解.class); --->获取对象身上的注解
			boolean is = isAnnotationPresent(注解.class);--->判断对象身上有没有注解
		4.通过注解对象拿到注解中存放的值
			
		
	
	