# mysql以及Oracle总结

## 博客精讲

@import "DataBaseIndex.md"

## sql语句执行顺序

@import "./img/sql执行顺序.jpg"

1. 从这个顺序中我们不难发现，所有的 查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。
    * 第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）
    * 第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2
    * 第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3
    * 第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。
    * 第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，
    1. 在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。
    1. 举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级='x'的话，left outer join会把x班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级='x' 因为它的过滤是最终的。
    * 第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。
    * 第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.
    * 第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。
    * 第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8.
    * 第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。
    * 第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。
    * 第十二步：应用top选项。此时才返回结果给请求者即用户。

## Oracle

### 中的分页查询

1. Oracle的分页查询语句基本上可以按照本文给出的格式来进行套用。
2. 分页查询格式：

```sql
<!-- 此处有一个疑问rownum既然是在排序之前查询之后生成的,为什么where中可以使用rownum呢? -->
<!-- 解决:因为每一个条件语句的查询都会生成一个 虚拟表,在生成虚拟表的同时,rownum就会生成-->
SELECT *
  FROM (SELECT a.*, ROWNUM rn
          FROM (SELECT *
                  FROM table_name) a
         WHERE ROWNUM <= 40)
 WHERE rn >= 21
```

1. 其中最内层的查询SELECT \* FROM TABLE_NAME 表示不进行翻页的原始查询语句.ROWNUM <= 40和RN >= 21控制分页查询的每页的范围.
2. 上面给出的这个分页查询语句,在大多数情况拥有较高的效率.分页的目的就是控制输出结果集大小,将结果尽快的返回.
3. 在上面的分页查询语句中,这种考虑主要体现在WHERE ROWNUM <= 40这句上。
4. 选择第21到40条记录存在两种方法
    * 一种是上面例子中展示的在查询的第二层通过ROWNUM <= 40来控制最大值，在查询的最外层控制最小值。
    * 另一种方式是去掉查询第二层的WHERE ROWNUM <= 40语句，在查询的最外层控制分页的最小值和最大值。
    这是，查询语句如下：

```sql
SELECT *

  FROM (SELECT a.*, ROWNUM rn

          FROM (SELECT *

                  FROM table_name) a)

 WHERE rn BETWEEN 21 AND 40
```

1. 对比这两种写法,绝大多数的情况下,第一个查询的效率比第二个高得多.这是由于CBO优化模式下,Oracle可以将外层的查询条件推倒内层查询中,以提高内层查询的执行效率.
    * 对于第一个查询语句，第二层的查询条件WHERE ROWNUM <= 40就可以被Oracle推入到内层查询中，
    这样Oracle查询的结果一旦超过了ROWNUM限制条件，就终止查询将结果返回了。
    * 而第二个查询语句，由于查询条件BETWEEN 21 AND 40是存在于查询的第三层，
    而Oracle无法将第三层的查询条件推到最内层（即使推到最内层也没有意义，因为最内层查询不知道RN代表什么）。因此，对于第二个查询语句，Oracle最内层返回给中间层的是所有满足条件的数据
    ，而中间层返回给最外层的也是所有数据。数据的过滤在最外层完成，显然这个效率要比第一个查询低得多。
1. 上面分析的查询不仅仅是针对单表的简单查询，对于最内层查询是复杂的多表联合查询或最内层查询包含排序的情况一样有效。

---

1. 这里就不对包含排序的查询进行说明了,下一篇文章会通过例子来详细说明,
1. 下面简单讨论一下多表联合的情况.

 ```txt
 1. 对于最常见的等值表连接查询，CBO一般可能会采用两种连接方式NESTED LOOP和HASH JOIN
 （MERGE JOIN效比HASH JOIN效率低，一般CBO不会考虑）。在这里，由于使用了分页，因此指
 定了一个返回的最大记录数，NESTED LOOP在返回记录数超过最大值时可以马上停止并将结果
 返回给中间层，而HASH JOIN必须处理完所有结果集（MERGE JOIN也是）。
1. 那么在大部分的情况下，对于分页查询选择NESTED LOOP作为查询的连接方法具有较高的
效率（分页查询的时候绝大部分的情况是查询前几页的数据，越靠后面的页数访问几率越小）
。因此，如果不介意在系统中使用HINT的话，可以将分页的查询语句改写为：
 ```

```sql
SELECT *

  FROM (SELECT a.*, ROWNUM  rn

          FROM (SELECT *

                  FROM table_name) a

         WHERE ROWNUM <= 40)

 WHERE rn >= 21
 ```