# 初始化与清理

1. 创建一个类，它包含一个在定义时就被初始化了的String域，以及另一个通过构造器初始化的String域.这两种方式有何差异?

><个人认为就是一个定义时就初始化的String域就是在类中添加一个Static的变量  而通过构造器初始化的String是通过传参或者就是在类中定义一个String>

```Java
class Rock{
    Rock(){
        //第一种情况就是定义一个String
        String a = "1234";//此时需要new一个Rock才会有a 的初始化
        //第二种情况就是static
        static String a = "1234";//只要用到关于Rock这个应用或者对象就会初始化这个a
        System.out.pritnln("Rock ");
    }
}
public class SimpleConstructor{
    public static void main(String[] args){
        new Rock();
    }
}
```

1. 区分重载方法：每个重载的方法都必须有一个独一无二的参数类型列表

>注意：甚至参数顺序的不同也足以区分两个方法。不过，一般情况下别这样做，因为这会使代码难以维护。通过返回值来区分重载方法是行不通的。

1. static 是静态方法，尽量用类名来调用，类似于全局变量。它没有this方法
1. 清理：终结处理和垃圾回收  
    1. 对象<b>可能</b>不被垃圾回收
    2. 垃圾回收并不等于“析构”
    3. 垃圾回收只与内存有关//也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。
1. 记住，无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果java虚拟机JVM 并未面临内存耗尽的情形，他是不会浪费时间去执行垃圾回收以恢复内存的。
1. 垃圾回收器如何工作

>Java虚拟机会进行见识，如果所有对象都很稳定，垃圾回收器的效率降低的话，就会切换到“标记-清理”方式；同样，Java虚拟机会跟踪“标记-清扫”的效果，要是堆空间出现很多碎片，就会切换回“停止-复制”方式。这就是自适应技术。

1. 初始化顺序是先静态对象(如果它们尚未因前面的对象创建过程而被初始化)，而后是“非静态”对象。从输出结果中可以观察到这一点。在初始化一个类时先初始化构造器外的静态函数然后初始化非静态的函数，不管是在构造器前还是在后。
1. 总结一下对象创建过程  
    假设有名为Dog的类
    1. 即使没有显示地使用static关键字，构造器实际上也是静态方法。因此当首次创建类型为Dog的对象时(构造器可以看成静态方法),或者Dog类的静态方法/静态域首次被访问时Java解释器必须查找类路径,以定位Dog.class文件
    2. 然后载入Dog.class(后面会学到,浙江创建一个Class对象),有关静态初始化的所有动作都会执行.因此,静态初始化只在Class对象首次加载的时候进行一次.
    3. 当用new Dog()创建对象的时候,首先将在堆上为Dog对象分配足够的存储空间.
    4. 这块存储空间会被清零,这就自动地将Dog对象中的所有基本类型数据都设置成了默认值(对数字来说就是0,对布尔类型和字符型也相同),而引用则被设置成了null.
    5. 执行所有出现于字段定义处的初始化动作.
    6. 执行构造器.正如将在第七章所看到的,这可能会牵涉到很多动作尤其是涉及到继承的时候.