# 对象导论

>我们之所以将自然界分解,组织成各种概念,并按其含义分类,主要是因为我们是整个口语交流社会共同遵守的协议的参与者,这个协定以语言的形式固定下来....除非赞成这个协定中的有关语言信息的组织和分类,否则我们根本无法交谈.--Beanjamin Lee Whorf(1897~1941)

## 1.1抽象过程

>所有的编程语言都提供抽象机制.热门所能够解决的问题的复杂性直接取决于抽象的类型和质量.

1. 面向对象方式通过向程序员提供表示问题空间中的元素的工具.思想实质是:程序可以通过添加新类型的对象使自身适用于某个特定问题.因此当你在阅读藐视解决方案代码的同时,也是在阅读问题的表述.
2. OOP允许根据问题来描述问题,而不是根据运行解决方案的计算机来描述问题.
3. Alan Kay总结了第一个成功的面向对象语言,同时也是java所基于的语言之一的Smalltalk的五个基本特性.
    * 万物皆为对象.将对象视为奇特的变量,它可以存储数据,除此之外,你还可以要求它在自身上执行操作.理论上讲,你可以抽取待求解决问题的任何概念化构件(狗,建筑物,服务等),将其表示为程序中的对象
    * 程序是对象的集合,它们通过发送消息来告知彼此所要做的.
    * 每个对象都有自己的由其他对象所构成的储存.
    * 每个对象都拥有其类型.
    * 某一个特定类型的所有对象都可以接受同样的消息.

## 1.2每个对象都有一个接口

>亚里士多德大概是第一个深入研究类型(type)的哲学家.他提出所有的对象都是唯一的,但同时也是具有相同的特性和行为的对象所归属的类的一部分.

1. 创建抽象数据类型(类)是面向对象程序设计的基本概念之一.抽象数据类型的运行方式与内置(built-in)类型几乎完全一致:创建--然后操作.
2. 因为类描述了具有相同特性(数据元素)和行为(功能)的对象集合,所以一个类实际上就是一个数据类型.
3. 事实上,面向对象程序设计的挑战之一,就是在问题空间的元素和解空间的对象之间创建一对一的映射.

## 1.3每个对象都提供服务

>当正在试图开发或理解一个程序设计时,最好的方法之一就是将对象想象为"服务提供者",程序本身将向用户提供服务,它将通过调用其他对象提供的服务来实现这一目的.

1. 将对象看作是服务提供者还有一个附带的好处:它有助于提高对象的内聚性.高内聚是软件设计的基本质量要求之一:这意味者一个软件构件的各个方面"组合"的很好.

## 1.4被隐藏的具体实现

>将程序开发人员按照角色分为类创建者(那些创建新数据类型的程序员)和客户端程序员是大有裨益的.

1. 访问控制的第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分
2. 访问控制的第二个存在原因就是允许库设计者可以改变类内部的工作方式而不担心会影响到客户端程序员.

3. 利用private protect default来进行拦截
    * private就像你与客户端程序员之间的一堵墙.
    * protected关键字与private作用相当,差别仅在于继承的类可以访问protected成员,但是不能访问private成员.
    * default通常称为包访问权限,类可以访问在同一个包中的其他类,但是在包之外,这些成员如同指定了private一样.

## 1.5复用具体实现

>最简单的复用某个类的方式就是直接使用该类的一个对象,此外也可以将那个类的一个对象置于某个新的类中.我们称其为"创建一个成员对象".

1. 新的类可以由任意数量 任意类型的其他对象以任意可以实现类中想要功能的方式所组成.因为是在使用现有的类合成新的类,所以这种概念被称为组合(composition),如果组合是动态发生的,那么它通常被称为聚合(aggregation).组合经常被视为"has -a"(拥有)关系.汽车拥有引擎

## 1.6继承

>对象这种观念,本身就是十分方便的工具,使得你可以通过概念将数据和功能封装到一起,因此可以对问题空间的观念给出恰当的表示,而不是受制于必须使用底层机器语言.但是这样做还是有很多麻烦:在创建了一个类之后,即使另一个心累与其具有相似的功能,你还是得重新创建一个新类

1. 当继承现有类型时,也就创造了新的类型.这个新的类型不仅包括现有类型的所有成员(尽管private成员被隐藏了起来,并且不可访问),而且更重要的是他复制了基类的接口.也就是说,所有可以发送给基类对象的消息同时也可以发送给导出类对象.
2. 由于通过发送给类的消息的类型是不可知类的类型,所以这也就意味着导出类*与基类具有相同的类型*.

---

1. "是一个"与"像是一个"关系
    * 继承应该只覆盖基类的方法(而并不添加在基类中没有的新方法)?如果这样做,导出类和基类是完全相同的类型,因为它们具有完全相同的接口.在某种意义上,这是一种处理继承的理想方式,可以被视为纯粹替代,通常称之为替代原则.
    * 这种情况下基类与导出类之间的关系为is-a(是一个)关系.
2. 有时必须在导出类型中添加新的接口元素,这样也就扩展了接口.这个新的类型仍然可以替代基类,但是并不完美,因为基类无法访问新添加的方法.被描述为is-like-a(像是一个)的关系

@import "../notepicture/Chapter1-extends.png"

## 1.7伴随多态的可互换对象

>在处理类型的层次结构时,经常想把一个对象不当作它所属的特定类型来对待,而是将其当作其基类的对象来对待.这使得人们可以编写出不依赖于特定类型的代码.(泛化)

@import "../notepicture/Chapter1-polymorphic.png"

1. 当我们不需要特别的代码来判定处理的到底是那个一个类型:面向对象要诀:The compiler cannot make a function call in the traditional sense. The function call generated by a non-OOP compiler causes what is called early binding.而面向对象则使用了后期绑定的概念.
2. 为了执行后期绑定,java使用一小段特殊的代码来替代绝对地址调用.这段代码使用在对象中存储的信息来计算方法体的地址.C++是使用virtual关键字来实现的.
3. 在java中动态绑定是默认行为,不需要添加额外的关键字来实现多态.

## 1.8 单根继承结构

>在OOP中,自C++面世以来的一个问题就是是否所有的类最终都继承自单一的基类.在java中(事实上还包括除C++以外的所有OOP语言),答案是yes,这个终极基类的名字就是Object.

1. 单根继承结构中的所有对象都具有一个共用接口,所以它们归根结底都是相同的基本类型.
2. 单根继承结构保证所有对象都具备某些功能.
    * 每个对象上执行某些基本操作.所有对象都可以很容易地在堆上创建,而参数传递也得到了极大的简化.
3. 单根继承结构使垃圾回收器的实现变得容易很多,而垃圾回收器正是Java相对C++的重要改进之一.
    * 由于所有对象都保证具有其类型信息,因此不会因无法确定对象的类型而陷入僵局.这对于系统级别操作显得尤其重要,并且给编程带来了更大的灵活性.

## 1.9 容器

1. 需要对容器有所选择
    * 第一,不同容器提供了不同类型的接口和外部行为.
    * 第二,不同容器对于某些操作具有不同的效率.
2. 参数化类型
    * 在java SE5出现之前,容器的存储对象都只具有Java中的通用类型:Object.单根继承意味着所有东西都是Object类型,所以可以存储Object的容器可以存储任何东西.(不能持有基本类型,但是Java SE5的自动包装功能使得这项限制几乎不成什么问题了.)
    * 那么在使用容器时,我们需要对对象先向上转型为Object,然后取出对象引用时,还要向下转型为更具体的类型.(向下转型是危险的)
    * 那么创建这样的容器,它知道自己所保存的对象的类型,从而不需要向下转型以及消除犯错误的可能,这样会更有意义.
    * 解决方案就是参数化类型,在Java中成为泛型.

## 1.10对象的创建和生命周期.

>在使用对象时,最关键的问题之一便是它们的生成和销毁方式.