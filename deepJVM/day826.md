# 深入理解JAVA虚拟机

## 对象的创建

1. 在类加载检查通过后,接下来虚拟机将为新生对象分配内存.对象所需的内存大小在类加载完成后便可完全确定.
2. 内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头).
3. 接下来虚拟机要对对象进行必要的设置.
4. 上面工作都完成之后,从虚拟机的角度来看,一个新的对象已经产生了,但从Java程序的角度来看,对象创建才刚刚开始--\<init>方法还没有执行,所有的字段都还为0.所以一般来说(由字节码中是否跟随invokespecial指令所决定),执行new只I型那个之后会接着执行\<init>方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才完全产生出来.
5. **对象的布局**
6. 对象在内存储存的布局可分为3块区域:对象头(Header) 实例数据(Instance Data)和对齐补充(Padding).
* 对象头包括两部分信息.第一部分用于存储对象自身的运行时数据.(如哈希码,GC分代年龄,锁状态标志,线程持有的锁).
* 另一部分时类型指针,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例。
* 接下来的实例数据部分时对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。无论时从父类继承的还是在子类中定义的，都需要记录起来。

## 虚拟机类的加载机制

1. Java里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态链接这个特点实现的。
2. 两个语言上的约定：1. 每个Class文件都可能代表着java语言中的一个类或接口 2. Class文件并非特质于具体磁盘中的文件。应当时一串二进制的字节流。无论以何种形式存在都可以。
3. **类的加载时机**:加载(Loading) 验证(Verification) 准备(Preparation) 解析(Resolution) 初始化(Initialization) 使用(Using) 卸载(Unloading) 其中验证准备解析部分统称为连接.
4. 类的加载
* 使用new关键字实例化对象的时候 读取或设置一个类的静态字段(被final修饰 已在编译器把结果放入常量池的静态字段除外)的时候,以及调用一个类的静态方法的时候.
* 使用java.lang.refect包的方法对类进行发射调用的时候,如果没有进行过初始化,则需要先触发其初始化.
* 当初始化一个类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化.
* 当虚拟机启动时,用户需要指定一个要执行的主类(包括main()方法的那个类),虚拟机会先初始化这个主类.
* 当使用jdk1.7的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果时REF_getStatic REF_putStatic REF_invokeStatic的方法句柄,并且这个方法句柄所对应的类没有进行过初始化,则需要先触发其初始化.
* 注意除此之外所有引用类的方式都不会触发初始化,称为被动引用.

### 类的加载过程